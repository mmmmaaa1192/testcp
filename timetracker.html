<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>業務時間トラッカー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 画面全体の描画領域を確保し、スクロールバーを非表示にする */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* ダークな背景色 */
        }
        #trajectoryCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; /* トラッカーとパネルの背後に配置 */
        }
        #tracker {
            width: 48px; /* 初期サイズ */
            height: 48px;
            background-color: #f97316; /* オレンジ色 (画像未選択時のデフォルト) */
            border-radius: 50%;
            position: absolute;
            z-index: 30; /* パネル(z-20)より手前に表示 */
            box-shadow: 0 0 15px 5px rgba(249, 115, 22, 0.7);
            /* 動きと反転、サイズ変更を滑らかにする */
            transition: top 0.1s linear, left 0.1s linear, transform 0.3s ease, width 0.1s ease, height 0.1s ease;
            /* 背景画像用の設定 */
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        .info-panel {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        /* Range Sliderのつまみのスタイル */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        input[type=range]::-webkit-slider-runnable-track {
            background: #4b5563; /* gray-600 */
            height: 0.5rem;
            border-radius: 0.5rem;
        }
        input[type=range]::-moz-range-track {
            background: #4b5563; /* gray-600 */
            height: 0.5rem;
            border-radius: 0.5rem;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #f97316;
            cursor: pointer;
            border-radius: 50%;
            margin-top: -6px; /* トラックの中央に配置 */
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #f97316;
            cursor: pointer;
            border-radius: 50%;
        }
        /* Number inputのスピナーを非表示にする (任意) */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="text-white bg-gray-900">
    
    <canvas id="trajectoryCanvas"></canvas>
    <!-- 動くトラッカー要素 -->
    <div id="tracker"></div>

    <!-- パネルを中央に配置し、画面サイズに対応させるためのラッパー -->
    <div class="fixed inset-0 z-20 flex items-center justify-center p-4">
        <!-- 設定と情報表示パネル -->
        <div class="info-panel p-6 md:p-8 rounded-2xl shadow-2xl bg-gray-800/50 border border-gray-700/50 w-full max-w-md max-h-full overflow-y-auto">
            <h1 class="text-2xl md:text-3xl font-bold text-center mb-4 text-orange-400">業務時間トラッカー</h1>
            <p class="text-center text-gray-300 mb-6">設定した時間でドットが画面を一周します。</p>
            
            <div class="space-y-4 mb-6">
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="startTime" class="block mb-2 text-sm font-medium text-gray-300">開始時刻</label>
                        <input type="time" id="startTime" value="09:00" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-orange-500 focus:border-orange-500 block w-full p-2.5">
                    </div>
                    <div>
                        <label for="endTime" class="block mb-2 text-sm font-medium text-gray-300">終了時刻</label>
                        <input type="time" id="endTime" value="18:00" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-orange-500 focus:border-orange-500 block w-full p-2.5">
                    </div>
                </div>
                <div>
                     <label for="imageUpload" class="block mb-2 text-sm font-medium text-gray-300">トラッカー画像 (任意)</label>
                     <input type="file" id="imageUpload" accept="image/*,image/gif" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-orange-500 file:text-white hover:file:bg-orange-600 cursor-pointer">
                </div>
                 <div>
                    <label for="trackerColor" class="block mb-2 text-sm font-medium text-gray-300">デフォルト色</label>
                    <input type="color" id="trackerColor" value="#f97316" class="p-1 h-10 w-full block bg-gray-700 border border-gray-600 cursor-pointer rounded-lg">
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                         <label for="imageSize" class="block mb-2 text-sm font-medium text-gray-300">画像サイズ: <span id="imageSizeValue">48</span>px</label>
                         <input type="range" id="imageSize" min="24" max="128" value="48" class="w-full">
                    </div>
                     <div>
                        <label for="maxImageSize" class="block mb-2 text-sm font-medium text-gray-300">最大サイズ (px)</label>
                        <input type="number" id="maxImageSize" value="128" min="24" step="0.1" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-orange-500 focus:border-orange-500 block w-full p-2.5">
                    </div>
                </div>
                 <div>
                     <label for="trajectoryWidth" class="block mb-2 text-sm font-medium text-gray-300">軌跡の太さ: <span id="trajectoryWidthValue">8</span>px</label>
                     <input type="range" id="trajectoryWidth" min="0" max="50" value="8" step="1" class="w-full">
                </div>
            </div>
            
            <div class="bg-gray-700/50 p-4 rounded-lg text-sm space-y-2">
                 <p><strong>現在時刻:</strong> <span id="currentTime">--:--:--</span></p>
                 <p><strong>進捗率:</strong> <span id="progress">0.00</span>%</p>
                 <p class="hidden md:block"><strong>座標 (x, y):</strong> (<span id="coordinateX">0</span>, <span id="coordinateY">0</span>)</p>
            </div>
        </div>
    </div>

    <script>
        const tracker = document.getElementById('tracker');
        const startTimeInput = document.getElementById('startTime');
        const endTimeInput = document.getElementById('endTime');
        const imageUpload = document.getElementById('imageUpload');
        const imageSizeInput = document.getElementById('imageSize');
        const imageSizeValue = document.getElementById('imageSizeValue');
        const maxImageSizeInput = document.getElementById('maxImageSize');
        const trajectoryWidthInput = document.getElementById('trajectoryWidth');
        const trajectoryWidthValue = document.getElementById('trajectoryWidthValue');
        const trackerColorInput = document.getElementById('trackerColor');
        
        const currentTimeEl = document.getElementById('currentTime');
        const progressEl = document.getElementById('progress');
        const coordinateXEl = document.getElementById('coordinateX');
        const coordinateYEl = document.getElementById('coordinateY');
        
        const canvas = document.getElementById('trajectoryCanvas');
        const ctx = canvas.getContext('2d');

        let settings = {
            startTime: '09:00',
            endTime: '18:00',
            trajectoryWidth: 8,
            trackerColor: '#f97316',
            imageSize: 48,
            maxImageSize: 128
        };

        function saveSettings() {
            localStorage.setItem('workTrackerSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const savedSettings = localStorage.getItem('workTrackerSettings');
            if (savedSettings) {
                // 保存された設定を読み込む
                settings = JSON.parse(savedSettings);

                // UIの表示を読み込んだ設定に合わせる
                startTimeInput.value = settings.startTime;
                endTimeInput.value = settings.endTime;
                trackerColorInput.value = settings.trackerColor;
                imageSizeInput.value = settings.imageSize;
                imageSizeInput.max = settings.maxImageSize; // スライダーの最大値も復元
                maxImageSizeInput.value = settings.maxImageSize;
                trajectoryWidthInput.value = settings.trajectoryWidth;

                // UIの更新をトリガーして見た目に反映させる
                imageSizeInput.dispatchEvent(new Event('input'));
                maxImageSizeInput.dispatchEvent(new Event('input'));
                trajectoryWidthInput.dispatchEvent(new Event('input'));
                trackerColorInput.dispatchEvent(new Event('input'));
            }
        }
        
        // ページ読み込み時に設定を読み込む
        loadSettings();
        
        function setupCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setupCanvas();

        // --- Event Listeners ---
        startTimeInput.addEventListener('change', (e) => {
            settings.startTime = e.target.value;
            saveSettings();
        });
        endTimeInput.addEventListener('change', (e) => {
            settings.endTime = e.target.value;
            saveSettings();
        });
        
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    tracker.style.backgroundImage = `url('${event.target.result}')`;
                    tracker.style.backgroundColor = 'transparent';
                    tracker.style.borderRadius = '0';
                    tracker.style.boxShadow = 'none';
                };
                reader.readAsDataURL(file);
            }
        });

        imageSizeInput.addEventListener('input', (e) => {
            const newSize = e.target.value;
            tracker.style.width = `${newSize}px`;
            tracker.style.height = `${newSize}px`;
            imageSizeValue.textContent = parseFloat(newSize).toFixed(1);
            settings.imageSize = newSize;
            saveSettings();
        });
        
        maxImageSizeInput.addEventListener('input', (e) => {
            const newMax = parseFloat(e.target.value);
            const minSize = parseFloat(imageSizeInput.min);
            if (!isNaN(newMax) && newMax >= minSize) {
                imageSizeInput.max = newMax;
                if (parseFloat(imageSizeInput.value) > newMax) {
                    imageSizeInput.value = newMax;
                    imageSizeInput.dispatchEvent(new Event('input'));
                }
                settings.maxImageSize = newMax;
                saveSettings();
            }
        });
        
        trajectoryWidthInput.addEventListener('input', (e) => {
            const newWidth = e.target.value;
            settings.trajectoryWidth = newWidth;
            trajectoryWidthValue.textContent = newWidth;
            saveSettings();
        });

        trackerColorInput.addEventListener('input', (e) => {
            const newColor = e.target.value;
            settings.trackerColor = newColor;
            saveSettings();
            // 画像が設定されていない場合のみ色を変更
            if (!tracker.style.backgroundImage || tracker.style.backgroundImage === 'none') {
                let r = parseInt(newColor.slice(1, 3), 16);
                let g = parseInt(newColor.slice(3, 5), 16);
                let b = parseInt(newColor.slice(5, 7), 16);
                
                // 本体は不透明にし、影の色はrgbaで設定
                tracker.style.backgroundColor = newColor;
                tracker.style.boxShadow = `0 0 15px 5px rgba(${r}, ${g}, ${b}, 0.7)`;
            }
        });

        function drawTrajectory(progress) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (settings.trajectoryWidth <= 0) return;

            const screenWidth = canvas.width;
            const screenHeight = canvas.height;
            const perimeter = 2 * (screenWidth + screenHeight);
            
            function getColorForProgress(p) {
                const colorMorning = { r: 135, g: 206, b: 235 }; // Sky Blue
                const colorMidday  = { r: 255, g: 215, b: 0 };   // Gold
                const colorEvening = { r: 255, g: 69,  b: 0 };   // OrangeRed

                const pMidday = (screenWidth + screenHeight) / perimeter;

                let r, g, b;

                if (p <= pMidday) {
                    // Morning to Midday gradient
                    const localProgress = p / pMidday;
                    r = colorMorning.r + (colorMidday.r - colorMorning.r) * localProgress;
                    g = colorMorning.g + (colorMidday.g - colorMorning.g) * localProgress;
                    b = colorMorning.b + (colorMidday.b - colorMorning.b) * localProgress;
                } else {
                    // Midday to Evening gradient
                    const localProgress = (p - pMidday) / (1 - pMidday);
                    r = colorMidday.r + (colorEvening.r - colorMidday.r) * localProgress;
                    g = colorMidday.g + (colorEvening.g - colorMidday.g) * localProgress;
                    b = colorMidday.b + (colorEvening.b - colorMidday.b) * localProgress;
                }
                
                return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
            }

            ctx.lineWidth = settings.trajectoryWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            let distanceRemaining = perimeter * progress;

            // --- Define corner progress points ---
            const pTopRight = screenWidth / perimeter;
            const pBottomRight = (screenWidth + screenHeight) / perimeter;
            const pBottomLeft = (2 * screenWidth + screenHeight) / perimeter;

            // --- 1. Top Edge ---
            if (distanceRemaining > 0) {
                const segmentLength = Math.min(distanceRemaining, screenWidth);
                const gradient = ctx.createLinearGradient(0, 0, screenWidth, 0);
                gradient.addColorStop(0, getColorForProgress(0));
                gradient.addColorStop(1, getColorForProgress(pTopRight));
                
                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.moveTo(0, 0);
                ctx.lineTo(segmentLength, 0);
                ctx.stroke();
                distanceRemaining -= segmentLength;
            }

            // --- 2. Right Edge ---
            if (distanceRemaining > 0) {
                const segmentLength = Math.min(distanceRemaining, screenHeight);
                const gradient = ctx.createLinearGradient(0, 0, 0, screenHeight);
                gradient.addColorStop(0, getColorForProgress(pTopRight));
                gradient.addColorStop(1, getColorForProgress(pBottomRight));

                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.moveTo(screenWidth, 0);
                ctx.lineTo(screenWidth, segmentLength);
                ctx.stroke();
                distanceRemaining -= segmentLength;
            }

            // --- 3. Bottom Edge ---
            if (distanceRemaining > 0) {
                const segmentLength = Math.min(distanceRemaining, screenWidth);
                const gradient = ctx.createLinearGradient(screenWidth, 0, 0, 0);
                gradient.addColorStop(0, getColorForProgress(pBottomRight));
                gradient.addColorStop(1, getColorForProgress(pBottomLeft));
                
                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.moveTo(screenWidth, screenHeight);
                ctx.lineTo(screenWidth - segmentLength, screenHeight);
                ctx.stroke();
                distanceRemaining -= segmentLength;
            }

            // --- 4. Left Edge ---
            if (distanceRemaining > 0) {
                const segmentLength = Math.min(distanceRemaining, screenHeight);
                const gradient = ctx.createLinearGradient(0, screenHeight, 0, 0);
                gradient.addColorStop(0, getColorForProgress(pBottomLeft));
                gradient.addColorStop(1, getColorForProgress(1));

                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.moveTo(0, screenHeight);
                ctx.lineTo(0, screenHeight - segmentLength);
                ctx.stroke();
            }
        }


        function updateTrackerPosition(progress) {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const perimeter = 2 * (screenWidth + screenHeight);
            const currentDistance = perimeter * progress;

            let x = 0, y = 0; // The point on the perimeter path

            if (currentDistance < screenWidth) {
                x = currentDistance; y = 0; tracker.style.transform = 'scaleX(1)';
            } else if (currentDistance < screenWidth + screenHeight) {
                x = screenWidth; y = currentDistance - screenWidth; tracker.style.transform = 'scaleX(-1)';
            } else if (currentDistance < 2 * screenWidth + screenHeight) {
                x = screenWidth - (currentDistance - (screenWidth + screenHeight)); y = screenHeight; tracker.style.transform = 'scaleX(-1)';
            } else {
                x = 0; y = screenHeight - (currentDistance - (2 * screenWidth + screenHeight)); tracker.style.transform = 'scaleX(1)';
            }
            
            const trackerSize = tracker.offsetWidth;
            const isImageTracker = tracker.style.backgroundImage && tracker.style.backgroundImage !== 'none';
            let finalX, finalY;

            if (isImageTracker) {
                // Non-centered: align the image div's edge with the screen edge
                if (currentDistance < screenWidth) { // Top
                    finalX = x;
                    finalY = 0;
                } else if (currentDistance < screenWidth + screenHeight) { // Right
                    finalX = screenWidth - trackerSize;
                    finalY = y;
                } else if (currentDistance < 2 * screenWidth + screenHeight) { // Bottom
                    finalX = x - trackerSize;
                    finalY = screenHeight - trackerSize;
                } else { // Left
                    finalX = 0;
                    finalY = y - trackerSize;
                }
                // Clamp position to stay within bounds, important for corners
                finalX = Math.max(0, Math.min(screenWidth - trackerSize, finalX));
                finalY = Math.max(0, Math.min(screenHeight - trackerSize, finalY));

            } else {
                // Centered: align the tracker's center with the screen edge
                finalX = x - trackerSize / 2;
                finalY = y - trackerSize / 2;
            }
            
            tracker.style.left = `${finalX}px`;
            tracker.style.top = `${finalY}px`;

             if(coordinateXEl && coordinateYEl) {
                coordinateXEl.textContent = Math.round(x);
                coordinateYEl.textContent = Math.round(y);
            }
        }

        function animate() {
            const now = new Date();
            const todayStr = now.toISOString().slice(0, 10);
            const startTime = new Date(`${todayStr}T${settings.startTime}`);
            let endTime = new Date(`${todayStr}T${settings.endTime}`);

            if (endTime < startTime) endTime.setDate(endTime.getDate() + 1);

            let progress = 0;
            if (now >= startTime && now <= endTime) {
                const totalDuration = endTime.getTime() - startTime.getTime();
                const elapsedTime = now.getTime() - startTime.getTime();
                progress = Math.min(1, elapsedTime / totalDuration);
            } else if (now > endTime) {
                progress = 1;
            }
            
            const trackerSize = tracker.offsetWidth;
            const isImageTracker = tracker.style.backgroundImage && tracker.style.backgroundImage !== 'none';
            
            // Reset position if outside work hours
            if (now < startTime || now > endTime) {
                 if(isImageTracker) {
                    // Place image at the very corner
                    tracker.style.left = '0px';
                    tracker.style.top = '0px';
                 } else {
                    // Center the default tracker on the corner
                    tracker.style.left = `${-trackerSize / 2}px`;
                    tracker.style.top = `${-trackerSize / 2}px`;
                 }
                 tracker.style.transform = 'scaleX(1)';
            } else {
                 updateTrackerPosition(progress);
            }
           
            drawTrajectory(progress);
            
            currentTimeEl.textContent = now.toLocaleTimeString('ja-JP');
            progressEl.textContent = (progress * 100).toFixed(2);
            
            requestAnimationFrame(animate);
        }
        
        window.addEventListener('resize', () => {
            setupCanvas();
            // No need to call animate/draw here, the loop will handle it
        });
        animate();
    </script>
</body>
</html>

